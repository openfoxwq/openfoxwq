// Auto-generated by protoc-gen-go-foxwqrpc plugin. DO NOT EDIT.

package proto

import (
	"context"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"log"

	"google.golang.org/protobuf/proto"
)

type PlayClient interface {
	Login(context.Context, *MessageHeader, *LoginPlayServerRequest) (*ExtendedResponse[*MessageHeader, *LoginPlayServerResponse], error)
	ListPlayers(context.Context, *MessageHeader, *ListPlayersRequest) (ServerStream[*ExtendedResponse[*MessageHeader, *ListPlayersResponse]], error)
	GetPlayerInfo(context.Context, *MessageHeader, *GetPlayerInfoRequest) (*ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse], error)
	SyncPlayers(context.Context, *MessageHeader, *SyncPlayersRequest) (*ExtendedResponse[*MessageHeader, *SyncPlayersResponse], error)
	GetRoomInfo(context.Context, *MessageHeader, *GetRoomInfoRequest) (*ExtendedResponse[*MessageHeader, *GetRoomInfoResponse], error)
	EnterRoom(context.Context, *MessageHeader, *EnterRoomRequest) (*ExtendedResponse[*MessageHeader, *EnterRoomResponse], error)
	LeaveRoom(context.Context, *MessageHeader, *LeaveRoomRequest) (*ExtendedResponse[*MessageHeader, *LeaveRoomResponse], error)
	ListRoomParticipants(context.Context, *MessageHeader, *ListRoomParticipantsRequest) (*ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse], error)
	ListenPlayerOnlineCountEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]], error)
	ListenPlayerOnlineEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]], error)
	ListenPlayerOfflineEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]], error)
	ListenPlayerStateEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerStateEvent]], error)
	GetAutomatchStats(context.Context, *MessageHeader, *GetAutomatchStatsRequest) (*ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse], error)
	StartAutomatch(context.Context, *MessageHeader, *StartAutomatchRequest) (*ExtendedResponse[*MessageHeader, *StartAutomatchResponse], error)
	ListenAutomatchFoundEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]], error)
	StopAutomatch(context.Context, *MessageHeader, *StopAutomatchRequest) (*ExtendedResponse[*MessageHeader, *StopAutomatchResponse], error)
	AcceptMatch(context.Context, *MessageHeader, *AcceptMatchRequest) (*ExtendedResponse[*MessageHeader, *AcceptMatchResponse], error)
	SyncMatchTime(context.Context, *MessageHeader, *SyncMatchTimeRequest) (*ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse], error)
	Move(context.Context, *MessageHeader, *MoveRequest) (*ExtendedResponse[*MessageHeader, *MoveResponse], error)
	Pass(context.Context, *MessageHeader, *PassRequest) (*ExtendedResponse[*MessageHeader, *PassResponse], error)
	RequestCounting(context.Context, *MessageHeader, *RequestCountingRequest) (*ExtendedResponse[*MessageHeader, *RequestCountingResponse], error)
	SendCountingDecision(context.Context, *MessageHeader, *CountingDecision) (*ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse], error)
	Resign(context.Context, *MessageHeader, *ResignRequest) (*ExtendedResponse[*MessageHeader, *ResignResponse], error)
	ListenMatchStartEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *MatchStartEvent]], error)
	ListenNextMoveEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *NextMoveEvent]], error)
	ListenPassEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PassEvent]], error)
	ListenCountdownEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *CountdownEvent]], error)
	ListenResumeCountdownEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]], error)
	ListenCountingDecisions(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *CountingDecision]], error)
	ListenCountingEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *CountingEvent]], error)
	ListenGameResultEvents(context.Context, *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *GameResultEvent]], error)
	SyncTime(context.Context, *MessageHeader, *SyncTimeRequest) (*ExtendedResponse[*MessageHeader, *SyncTimeResponse], error)
	Unknown1(context.Context, *MessageHeader, *UnknownPlayRequest1) (*ExtendedResponse[*MessageHeader, *UnknownPlayResponse1], error)
	MACAddress() string
}

var (
	play_loginMsgTag                         = &MessageTag{}
	play_listPlayersMsgTag                   = &MessageTag{}
	play_getPlayerInfoMsgTag                 = &MessageTag{}
	play_syncPlayersMsgTag                   = &MessageTag{}
	play_getRoomInfoMsgTag                   = &MessageTag{}
	play_enterRoomMsgTag                     = &MessageTag{}
	play_leaveRoomMsgTag                     = &MessageTag{}
	play_listRoomParticipantsMsgTag          = &MessageTag{}
	play_listenPlayerOnlineCountEventsMsgTag = &MessageTag{}
	play_listenPlayerOnlineEventsMsgTag      = &MessageTag{}
	play_listenPlayerOfflineEventsMsgTag     = &MessageTag{}
	play_listenPlayerStateEventsMsgTag       = &MessageTag{}
	play_getAutomatchStatsMsgTag             = &MessageTag{}
	play_startAutomatchMsgTag                = &MessageTag{}
	play_listenAutomatchFoundEventsMsgTag    = &MessageTag{}
	play_stopAutomatchMsgTag                 = &MessageTag{}
	play_acceptMatchMsgTag                   = &MessageTag{}
	play_syncMatchTimeMsgTag                 = &MessageTag{}
	play_moveMsgTag                          = &MessageTag{}
	play_passMsgTag                          = &MessageTag{}
	play_requestCountingMsgTag               = &MessageTag{}
	play_sendCountingDecisionMsgTag          = &MessageTag{}
	play_resignMsgTag                        = &MessageTag{}
	play_listenMatchStartEventsMsgTag        = &MessageTag{}
	play_listenNextMoveEventsMsgTag          = &MessageTag{}
	play_listenPassEventsMsgTag              = &MessageTag{}
	play_listenCountdownEventsMsgTag         = &MessageTag{}
	play_listenResumeCountdownEventsMsgTag   = &MessageTag{}
	play_listenCountingDecisionsMsgTag       = &MessageTag{}
	play_listenCountingEventsMsgTag          = &MessageTag{}
	play_listenGameResultEventsMsgTag        = &MessageTag{}
	play_syncTimeMsgTag                      = &MessageTag{}
	play_unknown1MsgTag                      = &MessageTag{}
)

func init() {
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0A, 0x08, 0x01, 0x28, 0x20, 0x30, 0x06, 0x38, 0xA1, 0x9C, 0x01}, play_loginMsgTag); err != nil {
		log.Fatalf("loading message tag for method Login: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xC9, 0x01, 0x28, 0x20, 0x30, 0x06, 0x38, 0xCE, 0x9C, 0x01}, play_listPlayersMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListPlayers: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xE9, 0x07, 0x28, 0x20, 0x30, 0x06, 0x38, 0xCB, 0x9C, 0x01}, play_getPlayerInfoMsgTag); err != nil {
		log.Fatalf("loading message tag for method GetPlayerInfo: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0D, 0x08, 0xCB, 0x01, 0x28, 0x20, 0x30, 0x06, 0x38, 0xCE, 0x9C, 0x01, 0x40, 0x03}, play_syncPlayersMsgTag); err != nil {
		log.Fatalf("loading message tag for method SyncPlayers: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0A, 0x08, 0x7A, 0x28, 0x20, 0x30, 0x06, 0x38, 0xC0, 0xEA, 0x01}, play_getRoomInfoMsgTag); err != nil {
		log.Fatalf("loading message tag for method GetRoomInfo: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0A, 0x08, 0x64, 0x28, 0x20, 0x30, 0x06, 0x38, 0xC5, 0xEA, 0x01}, play_enterRoomMsgTag); err != nil {
		log.Fatalf("loading message tag for method EnterRoom: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0A, 0x08, 0x65, 0x28, 0x20, 0x30, 0x06, 0x38, 0xC6, 0xEA, 0x01}, play_leaveRoomMsgTag); err != nil {
		log.Fatalf("loading message tag for method LeaveRoom: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0A, 0x08, 0x64, 0x28, 0x20, 0x30, 0x06, 0x38, 0xDA, 0xEA, 0x01}, play_listRoomParticipantsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListRoomParticipants: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0x91, 0x03, 0x38, 0xCE, 0x9C, 0x01}, play_listenPlayerOnlineCountEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenPlayerOnlineCountEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0x92, 0x03, 0x38, 0xCE, 0x9C, 0x01}, play_listenPlayerOnlineEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenPlayerOnlineEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0x93, 0x03, 0x38, 0xCE, 0x9C, 0x01}, play_listenPlayerOfflineEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenPlayerOfflineEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0x94, 0x03, 0x38, 0xCE, 0x9C, 0x01}, play_listenPlayerStateEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenPlayerStateEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0C, 0x08, 0xB1, 0x8E, 0x06, 0x28, 0x20, 0x30, 0x06, 0x38, 0xB6, 0xEA, 0x01}, play_getAutomatchStatsMsgTag); err != nil {
		log.Fatalf("loading message tag for method GetAutomatchStats: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0C, 0x08, 0xA2, 0x8E, 0x06, 0x28, 0x20, 0x30, 0x06, 0x38, 0xB6, 0xEA, 0x01}, play_startAutomatchMsgTag); err != nil {
		log.Fatalf("loading message tag for method StartAutomatch: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x08, 0x08, 0xAC, 0x8E, 0x06, 0x38, 0xB6, 0xEA, 0x01}, play_listenAutomatchFoundEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenAutomatchFoundEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0C, 0x08, 0xAB, 0x8E, 0x06, 0x28, 0x20, 0x30, 0x06, 0x38, 0xB6, 0xEA, 0x01}, play_stopAutomatchMsgTag); err != nil {
		log.Fatalf("loading message tag for method StopAutomatch: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0A, 0x08, 0x69, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_acceptMatchMsgTag); err != nil {
		log.Fatalf("loading message tag for method AcceptMatch: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xC8, 0x01, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_syncMatchTimeMsgTag); err != nil {
		log.Fatalf("loading message tag for method SyncMatchTime: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xC9, 0x01, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_moveMsgTag); err != nil {
		log.Fatalf("loading message tag for method Move: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xCC, 0x01, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_passMsgTag); err != nil {
		log.Fatalf("loading message tag for method Pass: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xAD, 0x02, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_requestCountingMsgTag); err != nil {
		log.Fatalf("loading message tag for method RequestCounting: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xB0, 0x02, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_sendCountingDecisionMsgTag); err != nil {
		log.Fatalf("loading message tag for method SendCountingDecision: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0B, 0x08, 0xB7, 0x02, 0x28, 0x20, 0x30, 0x06, 0x38, 0x98, 0xF2, 0x01}, play_resignMsgTag); err != nil {
		log.Fatalf("loading message tag for method Resign: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x06, 0x08, 0x6B, 0x38, 0x98, 0xF2, 0x01}, play_listenMatchStartEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenMatchStartEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0xCB, 0x01, 0x38, 0x98, 0xF2, 0x01}, play_listenNextMoveEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenNextMoveEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0xCE, 0x01, 0x38, 0x98, 0xF2, 0x01}, play_listenPassEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenPassEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x06, 0x08, 0x6C, 0x38, 0x98, 0xF2, 0x01}, play_listenCountdownEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenCountdownEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x06, 0x08, 0x6D, 0x38, 0x98, 0xF2, 0x01}, play_listenResumeCountdownEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenResumeCountdownEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0xB2, 0x02, 0x38, 0x98, 0xF2, 0x01}, play_listenCountingDecisionsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenCountingDecisions: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0xAF, 0x02, 0x38, 0x98, 0xF2, 0x01}, play_listenCountingEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenCountingEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x07, 0x08, 0x95, 0x03, 0x38, 0x98, 0xF2, 0x01}, play_listenGameResultEventsMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListenGameResultEvents: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0E, 0x08, 0x05, 0x28, 0x20, 0x30, 0x06, 0x38, 0xA1, 0x9C, 0x01, 0x40, 0x0B, 0x48, 0x01}, play_syncTimeMsgTag); err != nil {
		log.Fatalf("loading message tag for method SyncTime: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD8, 0xCC, 0x01, 0x10, 0xD8, 0xCC, 0x01, 0x1A, 0x0C, 0x08, 0x02, 0x28, 0x20, 0x30, 0x06, 0x38, 0xE0, 0xEA, 0x01, 0x40, 0x01}, play_unknown1MsgTag); err != nil {
		log.Fatalf("loading message tag for method Unknown1: %v", err)
	}
}

type playClientImpl struct {
	macAddr   string
	reqCh     chan frameWriterReq
	inFrameCh chan []byte
	errCh     chan error

	loginRequestCh                         chan internalUnaryReq[*LoginPlayServerRequest, *ExtendedResponse[*MessageHeader, *LoginPlayServerResponse]]
	listPlayersRequestCh                   chan internalServerStreamingReq[*ListPlayersRequest, *ExtendedResponse[*MessageHeader, *ListPlayersResponse]]
	getPlayerInfoRequestCh                 chan internalUnaryReq[*GetPlayerInfoRequest, *ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse]]
	syncPlayersRequestCh                   chan internalUnaryReq[*SyncPlayersRequest, *ExtendedResponse[*MessageHeader, *SyncPlayersResponse]]
	getRoomInfoRequestCh                   chan internalUnaryReq[*GetRoomInfoRequest, *ExtendedResponse[*MessageHeader, *GetRoomInfoResponse]]
	enterRoomRequestCh                     chan internalUnaryReq[*EnterRoomRequest, *ExtendedResponse[*MessageHeader, *EnterRoomResponse]]
	leaveRoomRequestCh                     chan internalUnaryReq[*LeaveRoomRequest, *ExtendedResponse[*MessageHeader, *LeaveRoomResponse]]
	listRoomParticipantsRequestCh          chan internalUnaryReq[*ListRoomParticipantsRequest, *ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse]]
	listenPlayerOnlineCountEventsRequestCh chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]]
	listenPlayerOnlineEventsRequestCh      chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]]
	listenPlayerOfflineEventsRequestCh     chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]]
	listenPlayerStateEventsRequestCh       chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerStateEvent]]
	getAutomatchStatsRequestCh             chan internalUnaryReq[*GetAutomatchStatsRequest, *ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse]]
	startAutomatchRequestCh                chan internalUnaryReq[*StartAutomatchRequest, *ExtendedResponse[*MessageHeader, *StartAutomatchResponse]]
	listenAutomatchFoundEventsRequestCh    chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]]
	stopAutomatchRequestCh                 chan internalUnaryReq[*StopAutomatchRequest, *ExtendedResponse[*MessageHeader, *StopAutomatchResponse]]
	acceptMatchRequestCh                   chan internalUnaryReq[*AcceptMatchRequest, *ExtendedResponse[*MessageHeader, *AcceptMatchResponse]]
	syncMatchTimeRequestCh                 chan internalUnaryReq[*SyncMatchTimeRequest, *ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse]]
	moveRequestCh                          chan internalUnaryReq[*MoveRequest, *ExtendedResponse[*MessageHeader, *MoveResponse]]
	passRequestCh                          chan internalUnaryReq[*PassRequest, *ExtendedResponse[*MessageHeader, *PassResponse]]
	requestCountingRequestCh               chan internalUnaryReq[*RequestCountingRequest, *ExtendedResponse[*MessageHeader, *RequestCountingResponse]]
	sendCountingDecisionRequestCh          chan internalUnaryReq[*CountingDecision, *ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse]]
	resignRequestCh                        chan internalUnaryReq[*ResignRequest, *ExtendedResponse[*MessageHeader, *ResignResponse]]
	listenMatchStartEventsRequestCh        chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *MatchStartEvent]]
	listenNextMoveEventsRequestCh          chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *NextMoveEvent]]
	listenPassEventsRequestCh              chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PassEvent]]
	listenCountdownEventsRequestCh         chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountdownEvent]]
	listenResumeCountdownEventsRequestCh   chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]]
	listenCountingDecisionsRequestCh       chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountingDecision]]
	listenCountingEventsRequestCh          chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountingEvent]]
	listenGameResultEventsRequestCh        chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *GameResultEvent]]
	syncTimeRequestCh                      chan internalUnaryReq[*SyncTimeRequest, *ExtendedResponse[*MessageHeader, *SyncTimeResponse]]
	unknown1RequestCh                      chan internalUnaryReq[*UnknownPlayRequest1, *ExtendedResponse[*MessageHeader, *UnknownPlayResponse1]]
}

func NewPlayClient(addr string, log *log.Logger) (PlayClient, error) {
	rwc, macAddr, err := newFrameChannel(addr)
	if err != nil {
		return nil, fmt.Errorf("connecting to %s: %v", addr, err)
	}

	frw := newLenEncodedFraming(rwc)
	inFrameCh := make(chan []byte, 8)
	reqCh := make(chan frameWriterReq, 8)
	errCh := make(chan error, 8)

	go frameWriter(frw, reqCh, errCh, log)
	go frameReader(frw, inFrameCh, errCh)

	loginRequestCh := make(chan internalUnaryReq[*LoginPlayServerRequest, *ExtendedResponse[*MessageHeader, *LoginPlayServerResponse]], 16)
	loginPending := &Queue[internalUnaryReq[*LoginPlayServerRequest, *ExtendedResponse[*MessageHeader, *LoginPlayServerResponse]]]{}
	listPlayersRequestCh := make(chan internalServerStreamingReq[*ListPlayersRequest, *ExtendedResponse[*MessageHeader, *ListPlayersResponse]], 16)
	listPlayersServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *ListPlayersResponse]]]struct{})
	getPlayerInfoRequestCh := make(chan internalUnaryReq[*GetPlayerInfoRequest, *ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse]], 16)
	getPlayerInfoPending := &Queue[internalUnaryReq[*GetPlayerInfoRequest, *ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse]]]{}
	syncPlayersRequestCh := make(chan internalUnaryReq[*SyncPlayersRequest, *ExtendedResponse[*MessageHeader, *SyncPlayersResponse]], 16)
	syncPlayersPending := &Queue[internalUnaryReq[*SyncPlayersRequest, *ExtendedResponse[*MessageHeader, *SyncPlayersResponse]]]{}
	getRoomInfoRequestCh := make(chan internalUnaryReq[*GetRoomInfoRequest, *ExtendedResponse[*MessageHeader, *GetRoomInfoResponse]], 16)
	getRoomInfoPending := &Queue[internalUnaryReq[*GetRoomInfoRequest, *ExtendedResponse[*MessageHeader, *GetRoomInfoResponse]]]{}
	enterRoomRequestCh := make(chan internalUnaryReq[*EnterRoomRequest, *ExtendedResponse[*MessageHeader, *EnterRoomResponse]], 16)
	enterRoomPending := &Queue[internalUnaryReq[*EnterRoomRequest, *ExtendedResponse[*MessageHeader, *EnterRoomResponse]]]{}
	leaveRoomRequestCh := make(chan internalUnaryReq[*LeaveRoomRequest, *ExtendedResponse[*MessageHeader, *LeaveRoomResponse]], 16)
	leaveRoomPending := &Queue[internalUnaryReq[*LeaveRoomRequest, *ExtendedResponse[*MessageHeader, *LeaveRoomResponse]]]{}
	listRoomParticipantsRequestCh := make(chan internalUnaryReq[*ListRoomParticipantsRequest, *ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse]], 16)
	listRoomParticipantsPending := &Queue[internalUnaryReq[*ListRoomParticipantsRequest, *ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse]]]{}
	listenPlayerOnlineCountEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]], 16)
	listenPlayerOnlineCountEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]]]struct{})
	listenPlayerOnlineEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]], 16)
	listenPlayerOnlineEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]]]struct{})
	listenPlayerOfflineEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]], 16)
	listenPlayerOfflineEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]]]struct{})
	listenPlayerStateEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerStateEvent]], 16)
	listenPlayerStateEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerStateEvent]]]struct{})
	getAutomatchStatsRequestCh := make(chan internalUnaryReq[*GetAutomatchStatsRequest, *ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse]], 16)
	getAutomatchStatsPending := &Queue[internalUnaryReq[*GetAutomatchStatsRequest, *ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse]]]{}
	startAutomatchRequestCh := make(chan internalUnaryReq[*StartAutomatchRequest, *ExtendedResponse[*MessageHeader, *StartAutomatchResponse]], 16)
	startAutomatchPending := &Queue[internalUnaryReq[*StartAutomatchRequest, *ExtendedResponse[*MessageHeader, *StartAutomatchResponse]]]{}
	listenAutomatchFoundEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]], 16)
	listenAutomatchFoundEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]]]struct{})
	stopAutomatchRequestCh := make(chan internalUnaryReq[*StopAutomatchRequest, *ExtendedResponse[*MessageHeader, *StopAutomatchResponse]], 16)
	stopAutomatchPending := &Queue[internalUnaryReq[*StopAutomatchRequest, *ExtendedResponse[*MessageHeader, *StopAutomatchResponse]]]{}
	acceptMatchRequestCh := make(chan internalUnaryReq[*AcceptMatchRequest, *ExtendedResponse[*MessageHeader, *AcceptMatchResponse]], 16)
	acceptMatchPending := &Queue[internalUnaryReq[*AcceptMatchRequest, *ExtendedResponse[*MessageHeader, *AcceptMatchResponse]]]{}
	syncMatchTimeRequestCh := make(chan internalUnaryReq[*SyncMatchTimeRequest, *ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse]], 16)
	syncMatchTimePending := &Queue[internalUnaryReq[*SyncMatchTimeRequest, *ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse]]]{}
	moveRequestCh := make(chan internalUnaryReq[*MoveRequest, *ExtendedResponse[*MessageHeader, *MoveResponse]], 16)
	movePending := &Queue[internalUnaryReq[*MoveRequest, *ExtendedResponse[*MessageHeader, *MoveResponse]]]{}
	passRequestCh := make(chan internalUnaryReq[*PassRequest, *ExtendedResponse[*MessageHeader, *PassResponse]], 16)
	passPending := &Queue[internalUnaryReq[*PassRequest, *ExtendedResponse[*MessageHeader, *PassResponse]]]{}
	requestCountingRequestCh := make(chan internalUnaryReq[*RequestCountingRequest, *ExtendedResponse[*MessageHeader, *RequestCountingResponse]], 16)
	requestCountingPending := &Queue[internalUnaryReq[*RequestCountingRequest, *ExtendedResponse[*MessageHeader, *RequestCountingResponse]]]{}
	sendCountingDecisionRequestCh := make(chan internalUnaryReq[*CountingDecision, *ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse]], 16)
	sendCountingDecisionPending := &Queue[internalUnaryReq[*CountingDecision, *ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse]]]{}
	resignRequestCh := make(chan internalUnaryReq[*ResignRequest, *ExtendedResponse[*MessageHeader, *ResignResponse]], 16)
	resignPending := &Queue[internalUnaryReq[*ResignRequest, *ExtendedResponse[*MessageHeader, *ResignResponse]]]{}
	listenMatchStartEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *MatchStartEvent]], 16)
	listenMatchStartEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *MatchStartEvent]]]struct{})
	listenNextMoveEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *NextMoveEvent]], 16)
	listenNextMoveEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *NextMoveEvent]]]struct{})
	listenPassEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PassEvent]], 16)
	listenPassEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PassEvent]]]struct{})
	listenCountdownEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountdownEvent]], 16)
	listenCountdownEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountdownEvent]]]struct{})
	listenResumeCountdownEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]], 16)
	listenResumeCountdownEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]]]struct{})
	listenCountingDecisionsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountingDecision]], 16)
	listenCountingDecisionsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountingDecision]]]struct{})
	listenCountingEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountingEvent]], 16)
	listenCountingEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountingEvent]]]struct{})
	listenGameResultEventsRequestCh := make(chan internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *GameResultEvent]], 16)
	listenGameResultEventsServerStreams := make(map[*serverStreamImpl[*ExtendedResponse[*MessageHeader, *GameResultEvent]]]struct{})
	syncTimeRequestCh := make(chan internalUnaryReq[*SyncTimeRequest, *ExtendedResponse[*MessageHeader, *SyncTimeResponse]], 16)
	syncTimePending := &Queue[internalUnaryReq[*SyncTimeRequest, *ExtendedResponse[*MessageHeader, *SyncTimeResponse]]]{}
	unknown1RequestCh := make(chan internalUnaryReq[*UnknownPlayRequest1, *ExtendedResponse[*MessageHeader, *UnknownPlayResponse1]], 16)
	unknown1Pending := &Queue[internalUnaryReq[*UnknownPlayRequest1, *ExtendedResponse[*MessageHeader, *UnknownPlayResponse1]]]{}
	go func() {
		var routerErr error
		for {
			select {
			case frame := <-inFrameCh:
				tag := uint32(binary.BigEndian.Uint16(frame[:2]))
				switch tag {
				case 0x6658:
					hdrLen := binary.BigEndian.Uint16(frame[3:5])
					hdrPayload := frame[5 : 5+hdrLen]
					hdr := &MessageHeader{}
					if err := proto.Unmarshal(hdrPayload, hdr); err != nil {
						log.Printf("unmarshalling header for LoginPlayServerResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
						routerErr = err
						continue
					}
					payload := frame[5+hdrLen : len(frame)-4]
					switch {
					case hdr.GetTag1() == 1 && hdr.GetTag2() == 20001:
						resp := &LoginPlayServerResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling LoginPlayServerResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !loginPending.Empty() {
							rr := loginPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *LoginPlayServerResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 201 && hdr.GetTag2() == 20046:
						resp := &ListPlayersResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling ListPlayersResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listPlayersServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *ListPlayersResponse]]
						for stream := range listPlayersServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *ListPlayersResponse]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listPlayersServerStreams, stream)
						}
					case hdr.GetTag1() == 1001 && hdr.GetTag2() == 20043:
						resp := &GetPlayerInfoResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling GetPlayerInfoResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !getPlayerInfoPending.Empty() {
							rr := getPlayerInfoPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 203 && hdr.GetTag2() == 20046:
						resp := &SyncPlayersResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling SyncPlayersResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !syncPlayersPending.Empty() {
							rr := syncPlayersPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *SyncPlayersResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 122 && hdr.GetTag2() == 30016:
						resp := &GetRoomInfoResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling GetRoomInfoResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !getRoomInfoPending.Empty() {
							rr := getRoomInfoPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *GetRoomInfoResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 100 && hdr.GetTag2() == 30021:
						resp := &EnterRoomResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling EnterRoomResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !enterRoomPending.Empty() {
							rr := enterRoomPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *EnterRoomResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 101 && hdr.GetTag2() == 30022:
						resp := &LeaveRoomResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling LeaveRoomResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !leaveRoomPending.Empty() {
							rr := leaveRoomPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *LeaveRoomResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 100 && hdr.GetTag2() == 30042:
						resp := &ListRoomParticipantsResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling ListRoomParticipantsResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !listRoomParticipantsPending.Empty() {
							rr := listRoomParticipantsPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 401 && hdr.GetTag2() == 20046:
						resp := &PlayerOnlineCountEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling PlayerOnlineCountEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenPlayerOnlineCountEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]]
						for stream := range listenPlayerOnlineCountEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenPlayerOnlineCountEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 402 && hdr.GetTag2() == 20046:
						resp := &PlayerOnlineEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling PlayerOnlineEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenPlayerOnlineEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]]
						for stream := range listenPlayerOnlineEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenPlayerOnlineEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 403 && hdr.GetTag2() == 20046:
						resp := &PlayerOfflineEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling PlayerOfflineEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenPlayerOfflineEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]]
						for stream := range listenPlayerOfflineEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenPlayerOfflineEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 404 && hdr.GetTag2() == 20046:
						resp := &PlayerStateEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling PlayerStateEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenPlayerStateEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerStateEvent]]
						for stream := range listenPlayerStateEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *PlayerStateEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenPlayerStateEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 100145 && hdr.GetTag2() == 30006:
						resp := &GetAutomatchStatsResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling GetAutomatchStatsResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !getAutomatchStatsPending.Empty() {
							rr := getAutomatchStatsPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 100130 && hdr.GetTag2() == 30006:
						resp := &StartAutomatchResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling StartAutomatchResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !startAutomatchPending.Empty() {
							rr := startAutomatchPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *StartAutomatchResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 100140 && hdr.GetTag2() == 30006:
						resp := &AutomatchFoundEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling AutomatchFoundEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenAutomatchFoundEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]]
						for stream := range listenAutomatchFoundEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenAutomatchFoundEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 100139 && hdr.GetTag2() == 30006:
						resp := &StopAutomatchResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling StopAutomatchResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !stopAutomatchPending.Empty() {
							rr := stopAutomatchPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *StopAutomatchResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 105 && hdr.GetTag2() == 31000:
						resp := &AcceptMatchResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling AcceptMatchResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !acceptMatchPending.Empty() {
							rr := acceptMatchPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *AcceptMatchResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 200 && hdr.GetTag2() == 31000:
						resp := &SyncMatchTimeResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling SyncMatchTimeResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !syncMatchTimePending.Empty() {
							rr := syncMatchTimePending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 201 && hdr.GetTag2() == 31000:
						resp := &MoveResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling MoveResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !movePending.Empty() {
							rr := movePending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *MoveResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 204 && hdr.GetTag2() == 31000:
						resp := &PassResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling PassResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !passPending.Empty() {
							rr := passPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *PassResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 301 && hdr.GetTag2() == 31000:
						resp := &RequestCountingResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling RequestCountingResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !requestCountingPending.Empty() {
							rr := requestCountingPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *RequestCountingResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 304 && hdr.GetTag2() == 31000:
						resp := &SendCountingDecisionResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling SendCountingDecisionResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !sendCountingDecisionPending.Empty() {
							rr := sendCountingDecisionPending.Pop()
							go func() {
								rr.respCh <- &ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse]{Header: hdr, Resp: resp}
							}()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 311 && hdr.GetTag2() == 31000:
						resp := &ResignResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling ResignResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !resignPending.Empty() {
							rr := resignPending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *ResignResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 107 && hdr.GetTag2() == 31000:
						resp := &MatchStartEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling MatchStartEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenMatchStartEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *MatchStartEvent]]
						for stream := range listenMatchStartEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *MatchStartEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenMatchStartEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 203 && hdr.GetTag2() == 31000:
						resp := &NextMoveEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling NextMoveEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenNextMoveEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *NextMoveEvent]]
						for stream := range listenNextMoveEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *NextMoveEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenNextMoveEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 206 && hdr.GetTag2() == 31000:
						resp := &PassEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling PassEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenPassEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *PassEvent]]
						for stream := range listenPassEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *PassEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenPassEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 108 && hdr.GetTag2() == 31000:
						resp := &CountdownEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling CountdownEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenCountdownEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountdownEvent]]
						for stream := range listenCountdownEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *CountdownEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenCountdownEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 109 && hdr.GetTag2() == 31000:
						resp := &ResumeCountdownEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling ResumeCountdownEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenResumeCountdownEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]]
						for stream := range listenResumeCountdownEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenResumeCountdownEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 306 && hdr.GetTag2() == 31000:
						resp := &CountingDecision{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling CountingDecision response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenCountingDecisionsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountingDecision]]
						for stream := range listenCountingDecisionsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *CountingDecision]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenCountingDecisionsServerStreams, stream)
						}
					case hdr.GetTag1() == 303 && hdr.GetTag2() == 31000:
						resp := &CountingEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling CountingEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenCountingEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountingEvent]]
						for stream := range listenCountingEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *CountingEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenCountingEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 405 && hdr.GetTag2() == 31000:
						resp := &GameResultEvent{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling GameResultEvent response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if len(listenGameResultEventsServerStreams) == 0 {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
						var closedStreams []*serverStreamImpl[*ExtendedResponse[*MessageHeader, *GameResultEvent]]
						for stream := range listenGameResultEventsServerStreams {
							select {
							case <-stream.closeCh:
								closedStreams = append(closedStreams, stream)
							case stream.respCh <- &ExtendedResponse[*MessageHeader, *GameResultEvent]{Header: hdr, Resp: resp}:
							}
						}
						for _, stream := range closedStreams {
							delete(listenGameResultEventsServerStreams, stream)
						}
					case hdr.GetTag1() == 5 && hdr.GetTag2() == 20001:
						resp := &SyncTimeResponse{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling SyncTimeResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !syncTimePending.Empty() {
							rr := syncTimePending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *SyncTimeResponse]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					case hdr.GetTag1() == 2 && hdr.GetTag2() == 30048:
						resp := &UnknownPlayResponse1{}
						if err := proto.Unmarshal(payload, resp); err != nil {
							log.Printf("unmarshalling UnknownPlayResponse1 response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
							routerErr = err
							continue
						}
						if !unknown1Pending.Empty() {
							rr := unknown1Pending.Pop()
							go func() { rr.respCh <- &ExtendedResponse[*MessageHeader, *UnknownPlayResponse1]{Header: hdr, Resp: resp} }()
						} else {
							log.Printf("PlayClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
						}
					default:
						log.Printf("PlayClient: dead letter: tag=%04X hdr_tag1=%08X hdr_tag2=%08X frame=%04X%s", tag, hdr.GetTag1(), hdr.GetTag2(), len(frame), hex.EncodeToString(frame))
					}
				default:
					log.Printf("PlayClient: dead letter: tag=%04X frame=%04X%s", tag, len(frame), hex.EncodeToString(frame))
				}
			case routerErr = <-errCh:
				log.Printf("PlayClient: router error set: %v", routerErr)
			case rr := <-loginRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_loginMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				loginPending.Push(rr)
			case rr := <-listPlayersRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_listPlayersMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				listPlayersServerStreams[rr.stream] = struct{}{}
			case rr := <-getPlayerInfoRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_getPlayerInfoMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				getPlayerInfoPending.Push(rr)
			case rr := <-syncPlayersRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_syncPlayersMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				syncPlayersPending.Push(rr)
			case rr := <-getRoomInfoRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_getRoomInfoMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				getRoomInfoPending.Push(rr)
			case rr := <-enterRoomRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_enterRoomMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				enterRoomPending.Push(rr)
			case rr := <-leaveRoomRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_leaveRoomMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				leaveRoomPending.Push(rr)
			case rr := <-listRoomParticipantsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_listRoomParticipantsMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				listRoomParticipantsPending.Push(rr)
			case rr := <-listenPlayerOnlineCountEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenPlayerOnlineCountEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenPlayerOnlineEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenPlayerOnlineEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenPlayerOfflineEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenPlayerOfflineEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenPlayerStateEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenPlayerStateEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-getAutomatchStatsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_getAutomatchStatsMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				getAutomatchStatsPending.Push(rr)
			case rr := <-startAutomatchRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_startAutomatchMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				startAutomatchPending.Push(rr)
			case rr := <-listenAutomatchFoundEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenAutomatchFoundEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-stopAutomatchRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_stopAutomatchMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				stopAutomatchPending.Push(rr)
			case rr := <-acceptMatchRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_acceptMatchMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				acceptMatchPending.Push(rr)
			case rr := <-syncMatchTimeRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_syncMatchTimeMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				syncMatchTimePending.Push(rr)
			case rr := <-moveRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_moveMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				movePending.Push(rr)
			case rr := <-passRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_passMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				passPending.Push(rr)
			case rr := <-requestCountingRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_requestCountingMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				requestCountingPending.Push(rr)
			case rr := <-sendCountingDecisionRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_sendCountingDecisionMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				sendCountingDecisionPending.Push(rr)
			case rr := <-resignRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_resignMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				resignPending.Push(rr)
			case rr := <-listenMatchStartEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenMatchStartEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenNextMoveEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenNextMoveEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenPassEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenPassEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenCountdownEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenCountdownEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenResumeCountdownEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenResumeCountdownEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenCountingDecisionsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenCountingDecisionsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenCountingEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenCountingEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-listenGameResultEventsRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				listenGameResultEventsServerStreams[rr.stream] = struct{}{}
			case rr := <-syncTimeRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_syncTimeMsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				syncTimePending.Push(rr)
			case rr := <-unknown1RequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				msgTag := proto.Clone(play_unknown1MsgTag).(*MessageTag)
				proto.Merge(msgTag.Header, rr.hdr)
				reqCh <- frameWriterReq{
					msgTag: msgTag,
					msg:    rr.req,
				}
				unknown1Pending.Push(rr)
			}
		}
	}()

	return &playClientImpl{
		macAddr:                                macAddr,
		inFrameCh:                              inFrameCh,
		reqCh:                                  reqCh,
		errCh:                                  errCh,
		loginRequestCh:                         loginRequestCh,
		listPlayersRequestCh:                   listPlayersRequestCh,
		getPlayerInfoRequestCh:                 getPlayerInfoRequestCh,
		syncPlayersRequestCh:                   syncPlayersRequestCh,
		getRoomInfoRequestCh:                   getRoomInfoRequestCh,
		enterRoomRequestCh:                     enterRoomRequestCh,
		leaveRoomRequestCh:                     leaveRoomRequestCh,
		listRoomParticipantsRequestCh:          listRoomParticipantsRequestCh,
		listenPlayerOnlineCountEventsRequestCh: listenPlayerOnlineCountEventsRequestCh,
		listenPlayerOnlineEventsRequestCh:      listenPlayerOnlineEventsRequestCh,
		listenPlayerOfflineEventsRequestCh:     listenPlayerOfflineEventsRequestCh,
		listenPlayerStateEventsRequestCh:       listenPlayerStateEventsRequestCh,
		getAutomatchStatsRequestCh:             getAutomatchStatsRequestCh,
		startAutomatchRequestCh:                startAutomatchRequestCh,
		listenAutomatchFoundEventsRequestCh:    listenAutomatchFoundEventsRequestCh,
		stopAutomatchRequestCh:                 stopAutomatchRequestCh,
		acceptMatchRequestCh:                   acceptMatchRequestCh,
		syncMatchTimeRequestCh:                 syncMatchTimeRequestCh,
		moveRequestCh:                          moveRequestCh,
		passRequestCh:                          passRequestCh,
		requestCountingRequestCh:               requestCountingRequestCh,
		sendCountingDecisionRequestCh:          sendCountingDecisionRequestCh,
		resignRequestCh:                        resignRequestCh,
		listenMatchStartEventsRequestCh:        listenMatchStartEventsRequestCh,
		listenNextMoveEventsRequestCh:          listenNextMoveEventsRequestCh,
		listenPassEventsRequestCh:              listenPassEventsRequestCh,
		listenCountdownEventsRequestCh:         listenCountdownEventsRequestCh,
		listenResumeCountdownEventsRequestCh:   listenResumeCountdownEventsRequestCh,
		listenCountingDecisionsRequestCh:       listenCountingDecisionsRequestCh,
		listenCountingEventsRequestCh:          listenCountingEventsRequestCh,
		listenGameResultEventsRequestCh:        listenGameResultEventsRequestCh,
		syncTimeRequestCh:                      syncTimeRequestCh,
		unknown1RequestCh:                      unknown1RequestCh,
	}, nil
}

func (c *playClientImpl) Login(_ context.Context, hdr *MessageHeader, req *LoginPlayServerRequest) (*ExtendedResponse[*MessageHeader, *LoginPlayServerResponse], error) {
	rr := internalUnaryReq[*LoginPlayServerRequest, *ExtendedResponse[*MessageHeader, *LoginPlayServerResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *LoginPlayServerResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.loginRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) ListPlayers(_ context.Context, hdr *MessageHeader, req *ListPlayersRequest) (ServerStream[*ExtendedResponse[*MessageHeader, *ListPlayersResponse]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *ListPlayersResponse]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *ListPlayersResponse], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[*ListPlayersRequest, *ExtendedResponse[*MessageHeader, *ListPlayersResponse]]{
		req:    req,
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listPlayersRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) GetPlayerInfo(_ context.Context, hdr *MessageHeader, req *GetPlayerInfoRequest) (*ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse], error) {
	rr := internalUnaryReq[*GetPlayerInfoRequest, *ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *GetPlayerInfoResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.getPlayerInfoRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) SyncPlayers(_ context.Context, hdr *MessageHeader, req *SyncPlayersRequest) (*ExtendedResponse[*MessageHeader, *SyncPlayersResponse], error) {
	rr := internalUnaryReq[*SyncPlayersRequest, *ExtendedResponse[*MessageHeader, *SyncPlayersResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *SyncPlayersResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.syncPlayersRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) GetRoomInfo(_ context.Context, hdr *MessageHeader, req *GetRoomInfoRequest) (*ExtendedResponse[*MessageHeader, *GetRoomInfoResponse], error) {
	rr := internalUnaryReq[*GetRoomInfoRequest, *ExtendedResponse[*MessageHeader, *GetRoomInfoResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *GetRoomInfoResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.getRoomInfoRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) EnterRoom(_ context.Context, hdr *MessageHeader, req *EnterRoomRequest) (*ExtendedResponse[*MessageHeader, *EnterRoomResponse], error) {
	rr := internalUnaryReq[*EnterRoomRequest, *ExtendedResponse[*MessageHeader, *EnterRoomResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *EnterRoomResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.enterRoomRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) LeaveRoom(_ context.Context, hdr *MessageHeader, req *LeaveRoomRequest) (*ExtendedResponse[*MessageHeader, *LeaveRoomResponse], error) {
	rr := internalUnaryReq[*LeaveRoomRequest, *ExtendedResponse[*MessageHeader, *LeaveRoomResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *LeaveRoomResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.leaveRoomRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) ListRoomParticipants(_ context.Context, hdr *MessageHeader, req *ListRoomParticipantsRequest) (*ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse], error) {
	rr := internalUnaryReq[*ListRoomParticipantsRequest, *ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *ListRoomParticipantsResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.listRoomParticipantsRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) ListenPlayerOnlineCountEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOnlineCountEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenPlayerOnlineCountEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenPlayerOnlineEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *PlayerOnlineEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOnlineEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenPlayerOnlineEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenPlayerOfflineEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *PlayerOfflineEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerOfflineEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenPlayerOfflineEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenPlayerStateEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PlayerStateEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *PlayerStateEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *PlayerStateEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PlayerStateEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenPlayerStateEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) GetAutomatchStats(_ context.Context, hdr *MessageHeader, req *GetAutomatchStatsRequest) (*ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse], error) {
	rr := internalUnaryReq[*GetAutomatchStatsRequest, *ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *GetAutomatchStatsResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.getAutomatchStatsRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) StartAutomatch(_ context.Context, hdr *MessageHeader, req *StartAutomatchRequest) (*ExtendedResponse[*MessageHeader, *StartAutomatchResponse], error) {
	rr := internalUnaryReq[*StartAutomatchRequest, *ExtendedResponse[*MessageHeader, *StartAutomatchResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *StartAutomatchResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.startAutomatchRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) ListenAutomatchFoundEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *AutomatchFoundEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *AutomatchFoundEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenAutomatchFoundEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) StopAutomatch(_ context.Context, hdr *MessageHeader, req *StopAutomatchRequest) (*ExtendedResponse[*MessageHeader, *StopAutomatchResponse], error) {
	rr := internalUnaryReq[*StopAutomatchRequest, *ExtendedResponse[*MessageHeader, *StopAutomatchResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *StopAutomatchResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.stopAutomatchRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) AcceptMatch(_ context.Context, hdr *MessageHeader, req *AcceptMatchRequest) (*ExtendedResponse[*MessageHeader, *AcceptMatchResponse], error) {
	rr := internalUnaryReq[*AcceptMatchRequest, *ExtendedResponse[*MessageHeader, *AcceptMatchResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *AcceptMatchResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.acceptMatchRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) SyncMatchTime(_ context.Context, hdr *MessageHeader, req *SyncMatchTimeRequest) (*ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse], error) {
	rr := internalUnaryReq[*SyncMatchTimeRequest, *ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *SyncMatchTimeResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.syncMatchTimeRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) Move(_ context.Context, hdr *MessageHeader, req *MoveRequest) (*ExtendedResponse[*MessageHeader, *MoveResponse], error) {
	rr := internalUnaryReq[*MoveRequest, *ExtendedResponse[*MessageHeader, *MoveResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *MoveResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.moveRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) Pass(_ context.Context, hdr *MessageHeader, req *PassRequest) (*ExtendedResponse[*MessageHeader, *PassResponse], error) {
	rr := internalUnaryReq[*PassRequest, *ExtendedResponse[*MessageHeader, *PassResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *PassResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.passRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) RequestCounting(_ context.Context, hdr *MessageHeader, req *RequestCountingRequest) (*ExtendedResponse[*MessageHeader, *RequestCountingResponse], error) {
	rr := internalUnaryReq[*RequestCountingRequest, *ExtendedResponse[*MessageHeader, *RequestCountingResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *RequestCountingResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.requestCountingRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) SendCountingDecision(_ context.Context, hdr *MessageHeader, req *CountingDecision) (*ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse], error) {
	rr := internalUnaryReq[*CountingDecision, *ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *SendCountingDecisionResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.sendCountingDecisionRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) Resign(_ context.Context, hdr *MessageHeader, req *ResignRequest) (*ExtendedResponse[*MessageHeader, *ResignResponse], error) {
	rr := internalUnaryReq[*ResignRequest, *ExtendedResponse[*MessageHeader, *ResignResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *ResignResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.resignRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) ListenMatchStartEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *MatchStartEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *MatchStartEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *MatchStartEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *MatchStartEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenMatchStartEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenNextMoveEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *NextMoveEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *NextMoveEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *NextMoveEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *NextMoveEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenNextMoveEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenPassEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *PassEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *PassEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *PassEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *PassEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenPassEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenCountdownEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *CountdownEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountdownEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *CountdownEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountdownEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenCountdownEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenResumeCountdownEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *ResumeCountdownEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *ResumeCountdownEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenResumeCountdownEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenCountingDecisions(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *CountingDecision]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountingDecision]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *CountingDecision], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountingDecision]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenCountingDecisionsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenCountingEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *CountingEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *CountingEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *CountingEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *CountingEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenCountingEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) ListenGameResultEvents(_ context.Context, hdr *MessageHeader) (ServerStream[*ExtendedResponse[*MessageHeader, *GameResultEvent]], error) {
	stream := &serverStreamImpl[*ExtendedResponse[*MessageHeader, *GameResultEvent]]{
		respCh:  make(chan *ExtendedResponse[*MessageHeader, *GameResultEvent], 8),
		closeCh: make(chan struct{}),
	}
	rr := internalServerStreamingReq[proto.Message, *ExtendedResponse[*MessageHeader, *GameResultEvent]]{
		hdr:    hdr,
		stream: stream,
		errCh:  make(chan error),
	}
	defer close(rr.errCh)
	c.listenGameResultEventsRequestCh <- rr
	select {
	case err := <-rr.errCh:
		return nil, err
	default:
		return rr.stream, nil
	}
}

func (c *playClientImpl) SyncTime(_ context.Context, hdr *MessageHeader, req *SyncTimeRequest) (*ExtendedResponse[*MessageHeader, *SyncTimeResponse], error) {
	rr := internalUnaryReq[*SyncTimeRequest, *ExtendedResponse[*MessageHeader, *SyncTimeResponse]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *SyncTimeResponse], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.syncTimeRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) Unknown1(_ context.Context, hdr *MessageHeader, req *UnknownPlayRequest1) (*ExtendedResponse[*MessageHeader, *UnknownPlayResponse1], error) {
	rr := internalUnaryReq[*UnknownPlayRequest1, *ExtendedResponse[*MessageHeader, *UnknownPlayResponse1]]{
		req:    req,
		hdr:    hdr,
		respCh: make(chan *ExtendedResponse[*MessageHeader, *UnknownPlayResponse1], 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.unknown1RequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *playClientImpl) MACAddress() string { return c.macAddr }
