// Auto-generated by protoc-gen-go-foxwqrpc plugin. DO NOT EDIT.

package proto

import (
	"context"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"log"

	"google.golang.org/protobuf/proto"
)

type NavigationClient interface {
	ListServers(context.Context, *ListServersRequest) (*ListServersResponse, error)
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	MACAddress() string
}

var (
	navigation_listServersMsgTag = &MessageTag{}
	navigation_loginMsgTag       = &MessageTag{}
)

func init() {
	if err := proto.Unmarshal([]byte{0x08, 0xB8, 0x17, 0x10, 0xBD, 0x17}, navigation_listServersMsgTag); err != nil {
		log.Fatalf("loading message tag for method ListServers: %v", err)
	}
	if err := proto.Unmarshal([]byte{0x08, 0xD0, 0x0F, 0x10, 0xD5, 0x0F}, navigation_loginMsgTag); err != nil {
		log.Fatalf("loading message tag for method Login: %v", err)
	}
}

type navigationClientImpl struct {
	macAddr   string
	reqCh     chan frameWriterReq
	inFrameCh chan []byte
	errCh     chan error

	listServersRequestCh chan internalUnaryReq[*ListServersRequest, *ListServersResponse]
	loginRequestCh       chan internalUnaryReq[*LoginRequest, *LoginResponse]
}

func NewNavigationClient(addr string, log *log.Logger) (NavigationClient, error) {
	rwc, macAddr, err := newFrameChannel(addr)
	if err != nil {
		return nil, fmt.Errorf("connecting to %s: %v", addr, err)
	}

	frw := NewLenEncodedFraming(rwc)
	inFrameCh := make(chan []byte, 8)
	reqCh := make(chan frameWriterReq, 8)
	errCh := make(chan error, 8)

	go frameWriter(frw, reqCh, errCh, log)
	go frameReader(frw, inFrameCh, errCh)

	listServersRequestCh := make(chan internalUnaryReq[*ListServersRequest, *ListServersResponse], 16)
	listServersPending := &Queue[internalUnaryReq[*ListServersRequest, *ListServersResponse]]{}
	loginRequestCh := make(chan internalUnaryReq[*LoginRequest, *LoginResponse], 16)
	loginPending := &Queue[internalUnaryReq[*LoginRequest, *LoginResponse]]{}
	go func() {
		var routerErr error
		for {
			select {
			case frame := <-inFrameCh:
				tag := uint32(binary.BigEndian.Uint16(frame[:2]))
				switch tag {
				case 0x0BBD:
					payload := frame[3 : len(frame)-4]
					resp := &ListServersResponse{}
					if err := proto.Unmarshal(payload, resp); err != nil {
						log.Printf("unmarshalling ListServersResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
						routerErr = err
						continue
					}
					if !listServersPending.Empty() {
						rr := listServersPending.Pop()
						go func() { rr.respCh <- resp }()
					} else {
						log.Printf("NavigationClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
					}
				case 0x07D5:
					payload := frame[3 : len(frame)-4]
					resp := &LoginResponse{}
					if err := proto.Unmarshal(payload, resp); err != nil {
						log.Printf("unmarshalling LoginResponse response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))
						routerErr = err
						continue
					}
					if !loginPending.Empty() {
						rr := loginPending.Pop()
						go func() { rr.respCh <- resp }()
					} else {
						log.Printf("NavigationClient: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)
					}
				default:
					log.Printf("NavigationClient: dead letter: tag=%04X frame=%04X%s", tag, len(frame), hex.EncodeToString(frame))
				}
			case routerErr = <-errCh:
				log.Printf("NavigationClient: router error set: %v", routerErr)
			case rr := <-listServersRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				reqCh <- frameWriterReq{
					msgTag: navigation_listServersMsgTag,
					msg:    rr.req,
				}
				listServersPending.Push(rr)
			case rr := <-loginRequestCh:
				if routerErr != nil {
					rr.errCh <- routerErr
				}
				reqCh <- frameWriterReq{
					msgTag: navigation_loginMsgTag,
					msg:    rr.req,
				}
				loginPending.Push(rr)
			}
		}
	}()

	return &navigationClientImpl{
		macAddr:              macAddr,
		inFrameCh:            inFrameCh,
		reqCh:                reqCh,
		errCh:                errCh,
		listServersRequestCh: listServersRequestCh,
		loginRequestCh:       loginRequestCh,
	}, nil
}

func (c *navigationClientImpl) ListServers(_ context.Context, req *ListServersRequest) (*ListServersResponse, error) {
	rr := internalUnaryReq[*ListServersRequest, *ListServersResponse]{
		req:    req,
		respCh: make(chan *ListServersResponse, 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.listServersRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *navigationClientImpl) Login(_ context.Context, req *LoginRequest) (*LoginResponse, error) {
	rr := internalUnaryReq[*LoginRequest, *LoginResponse]{
		req:    req,
		respCh: make(chan *LoginResponse, 1),
		errCh:  make(chan error),
	}
	defer close(rr.respCh)
	defer close(rr.errCh)
	c.loginRequestCh <- rr
	select {
	case resp := <-rr.respCh:
		return resp, nil
	case err := <-rr.errCh:
		return nil, err
	}
}

func (c *navigationClientImpl) MACAddress() string { return c.macAddr }
