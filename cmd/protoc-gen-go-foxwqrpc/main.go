package main

import (
	"fmt"
	"log"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"

	pb "github.com/openfoxwq/openfoxwq/proto" // strange loop :)
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate || len(f.Services) == 0 {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_foxwqrpc.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Auto-generated by protoc-gen-go-foxwqrpc plugin. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	if len(file.Services) > 1 {
		log.Fatalf("%s.proto: only one service definition per file allowed", file.GeneratedFilenamePrefix)
	}
	for _, svc := range file.Services {
		generateServiceClient(g, svc)
	}

	return g
}

type rpcType int

const (
	rpcTypeUnary rpcType = iota
	rpcTypeServerStreaming
	rpcTypeClientStreaming
	rpcTypeBidi
)

type rpc struct {
	name   string
	typ    rpcType
	msgTag *pb.MessageTag
	input  *protogen.Message
	output *protogen.Message
}

type tagSet map[uint32]bool

func generateServiceClient(g *protogen.GeneratedFile, svc *protogen.Service) {
	// Collect RPC info
	var rpcs []rpc
	regTag, extTag := tagSet{}, tagSet{}
	for _, method := range svc.Methods {
		rpc := rpc{
			name:   method.GoName,
			msgTag: proto.GetExtension(method.Desc.Options(), pb.E_MsgTag).(*pb.MessageTag),
			input:  method.Input,
			output: method.Output,
		}
		switch {
		case !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer(): // unary
			rpc.typ = rpcTypeUnary
		case !method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer(): // server streaming
			rpc.typ = rpcTypeServerStreaming
		case method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer(): // client streaming
			rpc.typ = rpcTypeClientStreaming
		case method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer(): // bidi
			rpc.typ = rpcTypeBidi
		}
		rpcs = append(rpcs, rpc)
		if rpc.msgTag.Req != nil {
			if rpc.msgTag.Header == nil {
				regTag[rpc.msgTag.GetReq()] = true
			} else {
				extTag[rpc.msgTag.GetReq()] = true
			}
		}
		if rpc.msgTag.Resp != nil {
			if rpc.msgTag.Header == nil {
				regTag[rpc.msgTag.GetResp()] = true
			} else {
				extTag[rpc.msgTag.GetResp()] = true
			}
		}
	}

	// Make sure that regular and extended tags are disjoint
	for tag := range regTag {
		if extTag[tag] {
			log.Fatalf("ambiguous tag %d is used both in regular and extended messages", tag)
		}
	}

	// Add import section
	// TODO use g.QualifiedGoIdent()
	g.P("import (")
	g.P(`    "context"`)
	g.P(`    "encoding/binary"`)
	g.P(`    "encoding/hex"`)
	g.P(`    "fmt"`)
	g.P(`    "log"`)
	g.P()
	g.P(`    "google.golang.org/protobuf/proto"`)
	g.P(")")

	generateClientInterface(g, svc.GoName, rpcs)
	generateMessageTagInitializer(g, svc.GoName, rpcs)
	generateClientImplementation(g, svc.GoName, rpcs)
}

func generateClientInterface(g *protogen.GeneratedFile, name string, rpcs []rpc) {
	g.P("type ", name, "Client interface {")
	for _, rpc := range rpcs {
		hdrArg := ""
		respType := "*" + rpc.output.GoIdent.GoName
		if rpc.msgTag.Header != nil {
			hdrArg = "*MessageHeader, "
			respType = fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpc.output.GoIdent.GoName)
		}
		switch rpc.typ {
		case rpcTypeUnary:
			switch {
			case isEmpty(rpc.input) && isEmpty(rpc.output): // no input/output
				log.Fatalf("%s: either input or output must not be empty", rpc.name)
			case isEmpty(rpc.input) && !isEmpty(rpc.output): // no input
				log.Fatalf("%s: unary rpc input must not be empty", rpc.name)
			case !isEmpty(rpc.input) && isEmpty(rpc.output): // no output
				g.P("    ", rpc.name, "(context.Context, ", hdrArg, "*", rpc.input.GoIdent.GoName, ") error")
			case !isEmpty(rpc.input) && !isEmpty(rpc.output):
				g.P("    ", rpc.name, "(context.Context, ", hdrArg, "*", rpc.input.GoIdent.GoName, ") (", respType, ", error)")
			}
		case rpcTypeServerStreaming:
			switch {
			case isEmpty(rpc.input) && isEmpty(rpc.output): // no input/output
				log.Fatalf("%s: either input or output must not be empty", rpc.name)
			case isEmpty(rpc.input) && !isEmpty(rpc.output): // no input
				g.P("    ", rpc.name, "(context.Context, ", hdrArg, ") (ServerStream[", respType, "], error)")
			case !isEmpty(rpc.input) && isEmpty(rpc.output): // no output
				log.Fatalf("%s: server streaming output must not be empty", rpc.name)
			case !isEmpty(rpc.input) && !isEmpty(rpc.output):
				g.P("    ", rpc.name, "(context.Context, ", hdrArg, "*", rpc.input.GoIdent.GoName, ") (ServerStream[", respType, "], error)")
			}
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}
	g.P("    MACAddress() string")
	g.P("}")
	g.P("")
}

func generateMessageTagInitializer(g *protogen.GeneratedFile, name string, rpcs []rpc) {
	g.P("var (")
	for _, rpc := range rpcs {
		id := lc(name) + "_" + lc(rpc.name) + "MsgTag"
		g.P("    ", id, " = &MessageTag{}")
	}
	g.P(")")
	g.P()

	g.P("func init() {")
	for _, rpc := range rpcs {
		id := lc(name) + "_" + lc(rpc.name) + "MsgTag"
		b, err := proto.Marshal(rpc.msgTag)
		if err != nil {
			log.Fatalf("marshalling message tag for %s: %v", rpc.name, err)
		}
		var elems []string
		for _, bi := range b {
			elems = append(elems, fmt.Sprintf("0x%02X", bi))
		}
		g.P("    if err := proto.Unmarshal([]byte{", strings.Join(elems, ", "), "}, ", id, "); err != nil {")
		g.P(`        log.Fatalf("loading message tag for method `, rpc.name, `: %v", err)`)
		g.P("    }")
	}
	g.P("}")
	g.P()
}

func generateClientImplementation(g *protogen.GeneratedFile, name string, rpcs []rpc) {
	clientImplName := fmt.Sprintf("%sClientImpl", lc(name))
	g.P("type ", clientImplName, " struct {")
	g.P("    macAddr string")
	g.P("    reqCh chan frameWriterReq")
	g.P("    inFrameCh chan []byte")
	g.P("    errCh chan error")
	g.P()
	for _, rpc := range rpcs {
		respType := "*" + rpc.output.GoIdent.GoName
		if rpc.msgTag.Header != nil {
			respType = fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpc.output.GoIdent.GoName)
		}
		switch rpc.typ {
		case rpcTypeUnary:
			switch {
			case isEmpty(rpc.input) && isEmpty(rpc.output): // no input/output
				log.Fatalf("%s: either input or output must not be empty", rpc.name)
			case isEmpty(rpc.input) && !isEmpty(rpc.output): // no input
				log.Fatalf("%s: unary rpc input must not be empty", rpc.name)
			case !isEmpty(rpc.input) && isEmpty(rpc.output): // no output
				g.P("    ", lc(rpc.name), "RequestCh chan internalUnaryReq[*", rpc.input.GoIdent.GoName, ", proto.Message]")
			case !isEmpty(rpc.input) && !isEmpty(rpc.output):
				g.P("    ", lc(rpc.name), "RequestCh chan internalUnaryReq[*", rpc.input.GoIdent.GoName, ", ", respType, "]")
			}
		case rpcTypeServerStreaming:
			respType := "*" + rpc.output.GoIdent.GoName
			if rpc.msgTag.Header != nil {
				respType = fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpc.output.GoIdent.GoName)
			}
			switch {
			case isEmpty(rpc.input) && isEmpty(rpc.output): // no input/output
				log.Fatalf("%s: either input or output must not be empty", rpc.name)
			case isEmpty(rpc.input) && !isEmpty(rpc.output): // no input
				g.P(lc(rpc.name), "RequestCh chan internalServerStreamingReq[proto.Message, ", respType, "]")
			case !isEmpty(rpc.input) && isEmpty(rpc.output): // no output
				log.Fatalf("%s: server streaming output must not be empty", rpc.name)
			case !isEmpty(rpc.input) && !isEmpty(rpc.output):
				g.P(lc(rpc.name), "RequestCh chan internalServerStreamingReq[*", rpc.input.GoIdent.GoName, ", ", respType, "]")
			}
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}
	g.P("}")
	g.P()
	g.P("func New", name, "Client(addr string, log *log.Logger) (", name, "Client, error) {")
	g.P(`    rwc, macAddr, err := newFrameChannel(addr)`)
	g.P(`    if err != nil {`)
	g.P(`    	return nil, fmt.Errorf("connecting to %s: %v", addr, err)`)
	g.P(`    }`)
	g.P()
	g.P(`    frw := NewLenEncodedFraming(rwc)`)
	g.P(`    inFrameCh := make(chan []byte, 8)`)
	g.P(`    reqCh := make(chan frameWriterReq, 8)`)
	g.P(`    errCh := make(chan error, 8)`)
	g.P()
	g.P(`    go frameWriter(frw, reqCh, errCh, log)`)
	g.P(`    go frameReader(frw, inFrameCh, errCh)`)
	g.P()
	for _, rpc := range rpcs {
		respType := "*" + rpc.output.GoIdent.GoName
		if rpc.msgTag.Header != nil {
			respType = fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpc.output.GoIdent.GoName)
		}
		switch rpc.typ {
		case rpcTypeUnary:
			switch {
			case isEmpty(rpc.input) && isEmpty(rpc.output): // no input/output
				log.Fatalf("%s: either input or output must not be empty", rpc.name)
			case isEmpty(rpc.input) && !isEmpty(rpc.output): // no input
				log.Fatalf("%s: unary rpc input must not be empty", rpc.name)
			case !isEmpty(rpc.input) && isEmpty(rpc.output): // no output
				g.P("    ", lc(rpc.name), "RequestCh := make(chan internalUnaryReq[*", rpc.input.GoIdent.GoName, ", proto.Message], 16)")
			case !isEmpty(rpc.input) && !isEmpty(rpc.output):
				g.P("    ", lc(rpc.name), "RequestCh := make(chan internalUnaryReq[*", rpc.input.GoIdent.GoName, ", ", respType, "], 16)")
				g.P("    ", lc(rpc.name), "Pending := &Queue[internalUnaryReq[*", rpc.input.GoIdent.GoName, ", ", respType, "]]{}")
			}
		case rpcTypeServerStreaming:
			switch {
			case isEmpty(rpc.input) && isEmpty(rpc.output): // no input/output
				log.Fatalf("%s: either input or output must not be empty", rpc.name)
			case isEmpty(rpc.input) && !isEmpty(rpc.output): // no input
				g.P("    ", lc(rpc.name), "RequestCh := make(chan internalServerStreamingReq[proto.Message, ", respType, "], 16)")
				g.P("    ", lc(rpc.name), "ServerStreams := make(map[*serverStreamImpl[", respType, "]]struct{})")
			case !isEmpty(rpc.input) && isEmpty(rpc.output): // no output
				log.Fatalf("%s: server streaming output must not be empty", rpc.name)
			case !isEmpty(rpc.input) && !isEmpty(rpc.output):
				g.P("    ", lc(rpc.name), "RequestCh := make(chan internalServerStreamingReq[*", rpc.input.GoIdent.GoName, ", ", respType, "], 16)")
				g.P("    ", lc(rpc.name), "ServerStreams := make(map[*serverStreamImpl[", respType, "]]struct{})")
			}
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}

	// Request router
	g.P("    go func() {")
	g.P("        var routerErr error")
	g.P("        for {")
	g.P("            select {")
	g.P("            case frame := <-inFrameCh:")
	g.P("                tag := uint32(binary.BigEndian.Uint16(frame[:2]))")
	g.P("                switch tag {")
	usedRespTags := map[uint32]bool{}
	for _, rpc := range rpcs {
		if isEmpty(rpc.output) {
			continue
		}
		if usedRespTags[rpc.msgTag.GetResp()] {
			continue
		}
		usedRespTags[rpc.msgTag.GetResp()] = true
		switch rpc.typ {
		case rpcTypeUnary:
			if rpc.msgTag.Header == nil {
				g.P("                case ", fmt.Sprintf("0x%04X", rpc.msgTag.GetResp()), ":")
				g.P("                    payload := frame[3:len(frame)-4]")
				g.P("                    resp := &", rpc.output.GoIdent.GoName, "{}")
				g.P("                    if err := proto.Unmarshal(payload, resp); err != nil {")
				g.P(`                        log.Printf("unmarshalling `, rpc.output.GoIdent.GoName, ` response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))`)
				g.P("                        routerErr = err")
				g.P("                        continue")
				g.P("                    }")
				g.P("                    if !", lc(rpc.name), "Pending.Empty() {")
				g.P("                        rr := ", lc(rpc.name), "Pending.Pop()")
				g.P("                        go func() { rr.respCh <- resp }()")
				g.P("                    } else {")
				g.P(`                        log.Printf("`, name, `Client: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)`)
				g.P("                    }")
			} else {
				g.P("                case ", fmt.Sprintf("0x%04X", rpc.msgTag.GetResp()), ":")
				g.P("                    hdrLen := binary.BigEndian.Uint16(frame[3:5])")
				g.P("                    hdrPayload := frame[5:5+hdrLen]")
				g.P("                    hdr := &MessageHeader{}")
				g.P("                    if err := proto.Unmarshal(hdrPayload, hdr); err != nil {")
				g.P(`                        log.Printf("unmarshalling header for `, rpc.output.GoIdent.GoName, ` response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))`)
				g.P("                        routerErr = err")
				g.P("                        continue")
				g.P("                    }")
				g.P("                    payload := frame[5+hdrLen:len(frame)-4]")
				g.P("                    switch {")
				for _, rpcj := range rpcs {
					if rpcj.msgTag.GetResp() != rpc.msgTag.GetResp() {
						continue
					}
					respType := fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpcj.output.GoIdent.GoName)
					respValue := fmt.Sprintf("&ExtendedResponse[*MessageHeader, *%s]{Header: hdr, Resp: resp}", rpcj.output.GoIdent.GoName)
					g.P("                    case hdr.GetTag1()==", rpcj.msgTag.GetHeader().GetTag1(), " && hdr.GetTag2()==", rpcj.msgTag.GetHeader().GetTag2(), ":")
					g.P("                        resp := &", rpcj.output.GoIdent.GoName, "{}")
					g.P("                        if err := proto.Unmarshal(payload, resp); err != nil {")
					g.P(`                            log.Printf("unmarshalling `, rpcj.output.GoIdent.GoName, ` response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))`)
					g.P("                            routerErr = err")
					g.P("                            continue")
					g.P("                        }")
					switch rpcj.typ {
					case rpcTypeUnary:
						g.P("                        if !", lc(rpcj.name), "Pending.Empty() {")
						g.P("                            rr := ", lc(rpcj.name), "Pending.Pop()")
						g.P("                            go func () { rr.respCh <- ", respValue, " }()")
						g.P("                        } else {")
						g.P(`                            log.Printf("`, name, `Client: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)`)
						g.P("                        }")
					case rpcTypeServerStreaming:
						g.P("                        if len(", lc(rpcj.name), "ServerStreams) == 0 {")
						g.P(`                            log.Printf("`, name, `Client: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)`)
						g.P("                        }")
						g.P("                        var closedStreams []*serverStreamImpl[", respType, "]")
						g.P("                        for stream := range ", lc(rpcj.name), "ServerStreams {")
						g.P("                          select {")
						g.P("                          case <-stream.closeCh:")
						g.P("                              closedStreams = append(closedStreams, stream)")
						g.P("                          case stream.respCh <- ", respValue, ":")
						g.P("                          }")
						g.P("                        }")
						g.P("                        for _, stream := range closedStreams {")
						g.P("                            delete(", lc(rpcj.name), "ServerStreams, stream)")
						g.P("                        }")
					case rpcTypeClientStreaming:
						log.Fatalf("%s: client streaming unsupported", rpcj.name)
					case rpcTypeBidi:
						log.Fatalf("%s: bidirectional streaming unsupported", rpcj.name)
					}
				}
				g.P("                    default:")
				g.P(`                        log.Printf("`, name, `Client: dead letter: tag=%04X hdr_tag1=%08X hdr_tag2=%08X frame=%04X%s", tag, hdr.GetTag1(), hdr.GetTag2(), len(frame), hex.EncodeToString(frame))`)
				g.P("                    }")
			}
		case rpcTypeServerStreaming:
			if rpc.msgTag.Header == nil {
				g.P("                case ", fmt.Sprintf("0x%04X", rpc.msgTag.GetResp()), ":")
				g.P("                    payload := frame[3:len(frame)-4]")
				g.P("                    resp := &", rpc.output.GoIdent.GoName, "{}")
				g.P("                    if err := proto.Unmarshal(payload, resp); err != nil {")
				g.P(`                        log.Printf("unmarshalling `, rpc.output.GoIdent.GoName, ` response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))`)
				g.P("                        routerErr = err")
				g.P("                        continue")
				g.P("                    }")
				g.P("                    if len(", lc(rpc.name), "ServerStreams) == 0 {")
				g.P(`                        log.Printf("`, name, `Client: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)`)
				g.P("                    }")
				g.P("                    var closedStreams []*serverStreamImpl[*", rpc.output.GoIdent.GoName, "]")
				g.P("                    for stream := range ", lc(rpc.name), "ServerStreams {")
				g.P("                      select {")
				g.P("                      case <-stream.closeCh:")
				g.P("                          closedStreams = append(closedStreams, stream)")
				g.P("                      case stream.respCh <- resp:")
				g.P("                      }")
				g.P("                    }")
				g.P("                    for _, stream := range closedStreams {")
				g.P("                        delete(", lc(rpc.name), "ServerStreams, stream)")
				g.P("                    }")
			} else {
				g.P("                case ", fmt.Sprintf("0x%04X", rpc.msgTag.GetResp()), ":")
				g.P("                    hdrLen := binary.BigEndian.Uint16(frame[3:5])")
				g.P("                    hdrPayload := frame[5:5+hdrLen]")
				g.P("                    hdr := &MessageHeader{}")
				g.P("                    if err := proto.Unmarshal(hdrPayload, hdr); err != nil {")
				g.P(`                        log.Printf("unmarshalling header for `, rpc.output.GoIdent.GoName, ` response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))`)
				g.P("                        routerErr = err")
				g.P("                        continue")
				g.P("                    }")
				g.P("                    payload := frame[5+hdrLen:len(frame)-4]")
				g.P("                    switch {")
				for _, rpcj := range rpcs {
					if rpcj.msgTag.GetResp() != rpc.msgTag.GetResp() {
						continue
					}
					respType := fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpcj.output.GoIdent.GoName)
					respValue := fmt.Sprintf("&ExtendedResponse[*MessageHeader, *%s]{Header: hdr, Resp: resp}", rpcj.output.GoIdent.GoName)
					g.P("                    case hdr.GetTag1()==", rpcj.msgTag.GetHeader().GetTag1(), " && hdr.GetTag2()==", rpcj.msgTag.GetHeader().GetTag2(), ":")
					g.P("                        resp := &", rpcj.output.GoIdent.GoName, "{}")
					g.P("                        if err := proto.Unmarshal(payload, resp); err != nil {")
					g.P(`                        log.Printf("unmarshalling `, rpcj.output.GoIdent.GoName, ` response: %v\n\tframe: %04X%s", err, len(frame), hex.EncodeToString(frame))`)
					g.P("                            routerErr = err")
					g.P("                            continue")
					g.P("                        }")
					switch rpcj.typ {
					case rpcTypeUnary:
						g.P("                        if !", lc(rpcj.name), "Pending.Empty() {")
						g.P("                            rr := ", lc(rpcj.name), "Pending.Pop()")
						g.P("                            go func () { rr.respCh <- ", respValue, "}()")
						g.P("                        } else {")
						g.P(`                            log.Printf("`, name, `Client: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)`)
						g.P("                        }")
					case rpcTypeServerStreaming:
						g.P("                        if len(", lc(rpcj.name), "ServerStreams) == 0 {")
						g.P(`                            log.Printf("`, name, `Client: dead letter: %s { %v }", resp.ProtoReflect().Descriptor().Name(), resp)`)
						g.P("                        }")
						g.P("                        var closedStreams []*serverStreamImpl[", respType, "]")
						g.P("                        for stream := range ", lc(rpcj.name), "ServerStreams {")
						g.P("                          select {")
						g.P("                          case <-stream.closeCh:")
						g.P("                              closedStreams = append(closedStreams, stream)")
						g.P("                          case stream.respCh <- ", respValue, ":")
						g.P("                          }")
						g.P("                        }")
						g.P("                        for _, stream := range closedStreams {")
						g.P("                            delete(", lc(rpcj.name), "ServerStreams, stream)")
						g.P("                        }")
					case rpcTypeClientStreaming:
						log.Fatalf("%s: client streaming unsupported", rpcj.name)
					case rpcTypeBidi:
						log.Fatalf("%s: bidirectional streaming unsupported", rpcj.name)
					}
				}
				g.P("                    default:")
				g.P(`                        log.Printf("`, name, `Client: dead letter: tag=%04X hdr_tag1=%08X hdr_tag2=%08X frame=%04X%s", tag, hdr.GetTag1(), hdr.GetTag2(), len(frame), hex.EncodeToString(frame))`)
				g.P("                    }")
			}
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}
	g.P("                default:")
	g.P(`                    log.Printf("`, name, `Client: dead letter: tag=%04X frame=%04X%s", tag, len(frame), hex.EncodeToString(frame))`)
	g.P("                }")
	g.P("            case routerErr = <-errCh:")
	g.P(`                log.Printf("`, name, `Client: router error set: %v", routerErr)`)
	for _, rpc := range rpcs {
		msgTagVar := lc(name) + "_" + lc(rpc.name) + "MsgTag"
		switch rpc.typ {
		case rpcTypeUnary:
			g.P("            case rr := <-", lc(rpc.name), "RequestCh:")
			g.P("                if routerErr != nil {")
			g.P("                    rr.errCh <- routerErr")
			g.P("                }")
			if rpc.msgTag.Header == nil {
				g.P("                reqCh <- frameWriterReq{")
				g.P("                    msgTag: ", msgTagVar, ",")
				g.P("                    msg: rr.req,")
				g.P("                }")
			} else {
				g.P("                msgTag := proto.Clone(", msgTagVar, ").(*MessageTag)")
				g.P("                proto.Merge(msgTag.Header, rr.hdr)")
				g.P("                reqCh <- frameWriterReq{")
				g.P("                    msgTag: msgTag,")
				g.P("                    msg: rr.req,")
				g.P("                }")
			}
			if !isEmpty(rpc.output) {
				g.P("                ", lc(rpc.name), "Pending.Push(rr)")
			}
		case rpcTypeServerStreaming:
			g.P("            case rr := <-", lc(rpc.name), "RequestCh:")
			g.P("                if routerErr != nil {")
			g.P("                    rr.errCh <- routerErr")
			g.P("                }")
			if !isEmpty(rpc.input) {
				if rpc.msgTag.Header == nil {
					g.P("                reqCh <- frameWriterReq{")
					g.P("                    msgTag: ", msgTagVar, ",")
					g.P("                    msg: rr.req,")
					g.P("                }")
				} else {
					g.P("                msgTag := proto.Clone(", msgTagVar, ").(*MessageTag)")
					g.P("                proto.Merge(msgTag.Header, rr.hdr)")
					g.P("                reqCh <- frameWriterReq{")
					g.P("                    msgTag: msgTag,")
					g.P("                    msg: rr.req,")
					g.P("                }")
				}
			}
			g.P("                ", lc(rpc.name), "ServerStreams[rr.stream] = struct{}{}")
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}
	g.P("            }")
	g.P("        }")
	g.P("    }()")
	g.P()

	g.P("    return &", clientImplName, "{")
	g.P("        macAddr: macAddr,")
	g.P("        inFrameCh: inFrameCh,")
	g.P("        reqCh: reqCh,")
	g.P("        errCh: errCh,")
	for _, rpc := range rpcs {
		switch rpc.typ {
		case rpcTypeUnary:
			g.P("    ", lc(rpc.name), "RequestCh: ", lc(rpc.name), "RequestCh,")
		case rpcTypeServerStreaming:
			g.P("    ", lc(rpc.name), "RequestCh: ", lc(rpc.name), "RequestCh,")
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}
	g.P("    }, nil")
	g.P("}")
	g.P("")
	for _, rpc := range rpcs {
		switch rpc.typ {
		case rpcTypeUnary:
			hdrArg := ""
			respType := "*" + rpc.output.GoIdent.GoName
			if rpc.msgTag.Header != nil {
				hdrArg = "hdr *MessageHeader, "
				respType = fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpc.output.GoIdent.GoName)
			}
			if isEmpty(rpc.output) {
				g.P("func (c *", clientImplName, ") ", rpc.name, "(_ context.Context, ", hdrArg, "req *", rpc.input.GoIdent.GoName, ") error {")
				g.P("    rr := internalUnaryReq[*", rpc.input.GoIdent.GoName, ", proto.Message]{")
				g.P("        req: req,")
				if rpc.msgTag.Header != nil {
					g.P("        hdr: hdr,")
				}
				g.P("        errCh: make(chan error),")
				g.P("    }")
				g.P("    defer close(rr.errCh)")
				g.P("    c.", lc(rpc.name), "RequestCh <- rr")
				g.P("    select {")
				g.P("    case err := <-rr.errCh:")
				g.P("        return err")
				g.P("    default:")
				g.P("        return nil")
				g.P("    }")
				g.P("}")
				g.P()
			} else {
				g.P("func (c *", clientImplName, ") ", rpc.name, "(_ context.Context, ", hdrArg, "req *", rpc.input.GoIdent.GoName, ") (", respType, ", error) {")
				g.P("    rr := internalUnaryReq[*", rpc.input.GoIdent.GoName, ", ", respType, "]{")
				g.P("        req: req,")
				if rpc.msgTag.Header != nil {
					g.P("        hdr: hdr,")
				}
				g.P("        respCh: make(chan ", respType, ", 1),")
				g.P("        errCh: make(chan error),")
				g.P("    }")
				g.P("    defer close(rr.respCh)")
				g.P("    defer close(rr.errCh)")
				g.P("    c.", lc(rpc.name), "RequestCh <- rr")
				g.P("    select {")
				g.P("    case resp := <-rr.respCh:")
				g.P("        return resp, nil")
				g.P("    case err := <-rr.errCh:")
				g.P("        return nil, err")
				g.P("    }")
				g.P("}")
				g.P()
			}
		case rpcTypeServerStreaming:
			hdrArg := ""
			respType := "*" + rpc.output.GoIdent.GoName
			if rpc.msgTag.Header != nil {
				hdrArg = "hdr *MessageHeader, "
				respType = fmt.Sprintf("*ExtendedResponse[*MessageHeader, *%s]", rpc.output.GoIdent.GoName)
			}
			if isEmpty(rpc.input) {
				g.P("func (c *", clientImplName, ") ", rpc.name, "(_ context.Context, ", hdrArg, ") (ServerStream[", respType, "], error) {")
				g.P("    stream := &serverStreamImpl[", respType, "] {")
				g.P("        respCh: make(chan ", respType, ", 8),")
				g.P("        closeCh: make(chan struct{}),")
				g.P("    }")
				g.P("    rr := internalServerStreamingReq[proto.Message, ", respType, "]{")
				if rpc.msgTag.Header != nil {
					g.P("        hdr: hdr,")
				}
				g.P("        stream: stream,")
				g.P("        errCh: make(chan error),")
				g.P("    }")
				g.P("    defer close(rr.errCh)")
				g.P("    c.", lc(rpc.name), "RequestCh <- rr")
				g.P("    select {")
				g.P("    case err := <-rr.errCh:")
				g.P("        return nil, err")
				g.P("    default:")
				g.P("        return rr.stream, nil")
				g.P("    }")
				g.P("}")
				g.P()
			} else {
				g.P("func (c *", clientImplName, ") ", rpc.name, "(_ context.Context, ", hdrArg, "req *", rpc.input.GoIdent.GoName, ") (ServerStream[", respType, "], error) {")
				g.P("    stream := &serverStreamImpl[", respType, "] {")
				g.P("        respCh: make(chan ", respType, ", 8),")
				g.P("        closeCh: make(chan struct{}),")
				g.P("    }")
				g.P("    rr := internalServerStreamingReq[*", rpc.input.GoIdent.GoName, ", ", respType, "]{")
				g.P("        req: req,")
				if rpc.msgTag.Header != nil {
					g.P("        hdr: hdr,")
				}
				g.P("        stream: stream,")
				g.P("        errCh: make(chan error),")
				g.P("    }")
				g.P("    defer close(rr.errCh)")
				g.P("    c.", lc(rpc.name), "RequestCh <- rr")
				g.P("    select {")
				g.P("    case err := <-rr.errCh:")
				g.P("        return nil, err")
				g.P("    default:")
				g.P("        return rr.stream, nil")
				g.P("    }")
				g.P("}")
				g.P()
			}
		case rpcTypeClientStreaming:
			log.Fatalf("%s: client streaming unsupported", rpc.name)
		case rpcTypeBidi:
			log.Fatalf("%s: bidirectional streaming unsupported", rpc.name)
		}
	}
	g.P()

	g.P("func (c *", clientImplName, ") MACAddress() string { return c.macAddr }")
	g.P()
}

func isEmpty(msg *protogen.Message) bool {
	return msg.Desc.FullName() == "google.protobuf.Empty"
}

func lc(name string) string {
	return fmt.Sprintf("%s%s", strings.ToLower(name[:1]), name[1:])
}
